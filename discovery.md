服务注册流程
反注册流程
查询节点信息
订阅服务变更

首先从本机内存中查找，如果没有就继续下一步。把服务信息存在本机内存，主要是因为服务节点信息并不总是时刻变化的，并不需要每一次服务调用都要调用注册中心获取最新的节点信息，只需要在本机内存中保留最新的服务提供者的节点列表就可以

接着从本地快照中查找，如果没有就继续下一步。在本地磁盘存储一份服务提供者的节点信息的快照，这是因为服务消费者同注册中心之间的网络不一定总是可靠的，服务消费者重启时，本机内存中还不存在服务提供者的节点信息，如果此时调用注册中心失败，那么服务消费者就拿不到服务节点信息了，也就没法调用了。本地快照就是为了防止这种情况的发生，即使服务消费者重启后请求注册中心失败，依然可以读取本地快照，获取到服务节点信息

服务消费者从注册中心获取了服务的信息后，就订阅了服务的变化，会在本地保留 Cluster 的 sign 值
服务消费者每隔一段时间，调用 getSign() 函数，从注册中心获取服务端该 Cluster 的 sign 值，并与本地保留的 sign 值做对比，如果不一致，就从服务端拉取新的节点信息，并更新 localcache 和 snapshot




1.
consumer 通过 dns 解析到 lb 地址
consumer 通过 lb 访问 provider

lb 是单点


2.
lb 移到 consumer 内部
provider 注册到 service registry 中
consumer 带有服务发现与负载均衡功能，直接访问 provider

没有多一步的性能问题
没有 lb 单点问题

多语言环境，需要为每一个 consumer 开发对应的 lb


3.
lb 以一个独立进程的方式部署在主机上
provider 注册到 service registry 中
lb 定时同步 service registry 中的信息，具有服务发现和负载均衡功能
consumer 访问服务时，通过本地 lb 发起



服务注册接口：服务提供者通过调用服务注册接口来完成服务注册
服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销
心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报

服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表
服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表

后台管理的 API
服务查询接口：查询注册中心当前注册了哪些服务信息
服务修改接口：修改注册中心中某一服务的信息


服务健康状态检测
服务状态变更通知
白名单机制





节点管理
注册中心主动摘除机制
要求服务提供者定时的主动向注册中心汇报心跳，注册中心根据服务提供者节点最近一次汇报心跳的时间与上一次汇报心跳时间做比较，如果超出一定时间，就认为服务提供者出现问题，继而把节点从服务列表中摘除，并把最近的可用服务节点列表推送给服务消费者

服务消费者摘除机制
如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除


负载均衡
随机算法
轮询算法
最少活跃调用算法
一致性 Hash 算法

服务容错
FailOver：失败自动切换。就是服务消费者发现调用失败或者超时后，自动从可用的服务节点列表总选择下一个节点重新发起调用，也可以设置重试的次数。这种策略要求服务调用的操作必须是幂等的，也就是说无论调用多少次，只要是同一个调用，返回的结果都是相同的，一般适合服务调用是读请求的场景

FailBack：失败通知。就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。比如对于非幂等的调用场景，如果调用失败后，不能简单地重试，而是应该查询服务端的状态，看调用到底是否实际生效，如果已经生效了就不能再重试了；如果没有生效可以再发起一次调用

FailCache：失败缓存。就是服务消费者调用失败或者超时后，不立即发起重试，而是隔一段时间后再次尝试发起调用。比如后端服务可能一段时间内都有问题，如果立即发起重试，可能会加剧问题，反而不利于后端服务的恢复。如果隔一段时间待后端节点恢复后，再次发起调用效果会更好

FailFast：快速失败。就是服务消费者调用一次失败后，不再重试。实际在业务执行时，一般非核心业务的调用，会采用快速失败策略，调用失败后一般就记录下失败日志就返回了


用户 token
jwt token

身份认证是由 API Gateway 来做的，鉴权信息可能会在 API Gateway 中添加到 jwt token 中， 具体的权限判断逻辑在下游的业务系统中


修改大表结构后，通过 binlog  同步数据缓慢
加快刷盘，拉日志不慢，在从库回放慢，可以临时修改从库刷盘参数（牺牲安全性），加速导入


docker 审计方案怎么做？
问的同学是运维安全向的吗，是指的容器内操作的审计，还是容器镜像拉取推送呢。
大体整体如下：
（1）容器内操作的审计：可以走传统的堡垒机方案，逻辑是在连接容器时先在堡垒机运行录制程序或脚本，然后对命令进行记录或筛选。
（2）容器镜像拉取推送：需要实现代理，在仓库和用户间使用代理对请求进行过滤，案例的话可以具体实现可以参照harbor的代理模块

https://www.zhihu.com/question/52392988




mq 一般用在异步场景，解耦， 削峰等。
1.发出领域事件：比如注册，登录，充值，点赞，评论等关键事件。对这些事件感兴趣的服务可以自己去接收处理，处理不处理，处理是否快慢，都不会影响核心服务。
2.异步削峰：可以看作是同步 rpc 的一种降级方案，用于匹配快慢系统。比如活动领券，一般业务服务性能可以很高，但是发券服务要操作 db，有很多校验，甚至需要匹配第三方厂商，一般性能会比较低。高峰时直接发券会打垮发券服务，所以先告诉用户请求成功，发券会稍后到账，接收消息进行匀速的发券处理。
3.消息补偿：同步调 RPC 可能会网络失败，且不可能一直重试，可以将事务的下半部或失败补偿放入消息队列，由另一个服务去保证一致性，参见分布式一致性中的本地消息表和事务消息。


https://juejin.cn/post/6908220694929080333

dropbox 的 util 库

https://zhuanlan.zhihu.com/p/31866490

心跳开关保护机制

在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满
所以针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。

打开这个开关有一定代价，它会导致服务消费者感知最新的服务节点信息延迟，在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关


服务节点摘除保护机制

如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起雪崩。这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。

业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除



心跳机制直接用在服务消费者端
直接在服务消费者端根据调用服务提供者是否成功来判定服务提供者是否可用。如果服务消费者调用某一个服务提供者节点连续失败超过一定次数，可以在本地内存中将这个节点标记为不可用。并且每隔一段固定时间，服务消费者都要向标记为不可用的节点发起保活探测，如果探测成功了，就将标记为不可用的节点再恢复为可用状态，重新发起调用


HealthCheck
在服务提供者服务不稳定时，被消费者所感知，临时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。health check，同样也被用于外挂方式的容器健康检测，或者流量检测(k8s liveness & readiness)



客户端发现
一个服务实例被启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求

直连，比服务端服务发现少一次网络跳转，Consumer 需要内置特定的服务发现客户端和发现逻辑。


服务端发现
客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上

Consumer 无需关注服务发现具体细节，只需知道服务的 DNS 域名即可，支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失。




通过 Family(appid) 和 Addr(IP:Port) 定位实例，除此之外还可以附加更多的元数据：权重、染色标签、集群等
Provider  注册后定期(30s)心跳一次，注册， 心跳，下线都需要进行同步，注册和下线需要进行长轮询推送

Consumer 启动时拉取实例，发起30s长轮询

Server 定期(60s) 检测失效(90s)的实例，失效则剔除。短时间里丢失了大量的心跳连接(15分钟内心跳低于期望值*85%)，开启自我保护，保留过期服务不删除。




